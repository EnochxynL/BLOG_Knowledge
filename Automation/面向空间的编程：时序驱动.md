---
share: "true"
---
Verilog、Simulink、Labview、PLC等数据流编程语言，并没有明显的执行顺序所在。
物理世界，是天然的多线程。
所以，电气工程师的编程思路和程序员的编程思路有何不同？CPU是怎么把多线程的电路干成单线程的解释器的？怎么好好利用这物理世界的优势，免于调度，直接驱动我的多线程系统？
# 节点/元件
一个节点，其实类似数字电路IC，也就是Verilog的一个module
触发端口：让程序执行的端口，对应CLK输入
对于组合逻辑，可以认为always触发，或一旦有数据则触发
# 触发
在单线程CPU程序中，同时只能运行一个程序，于是需要一个调度器来调度各个模块的仿真
物理世界（如果假设你是虚拟人），也可以视为是无限细分的时间片轮询
在单片机里体现为中断，在编程思想里体现事件驱动（对应于轮询的消息驱动）（顺便提一嘴，组合逻辑、网表、跳转表对应的是数据驱动编程）

# **管道与导线**
数据有数据的流向，程序执行有程序执行的顺序。
单线程的语言，导线顺序本可以视为从上到下。
```c
int a = 3;
bool b = 4;
a = 5;
```
管道信号（一般的数据）和导线信号（触发）本来应该有明确的区分，但数字电路中没有区分。
区分：逻辑上可以抽象出一个“信号检测器”，对于上/下沿信号，输出尖脉冲。

管道信号的内容可以任意，导线信号的内容是离散的，只能是若干个尖脉冲。
就像工厂的流水线，有产品的传送带，也有工业设备的控制线缆。

# 寄存器与变量
`bool b`是变量的声明，可以视为对寄存器的声明。
在C语言中是`bool`变量，在数字电路中是D触发器。只是实现方式不同。
一个触发器可以是一个`module`模块，一个组合电路或者时序电路也是。

所以，又说到了面向对象。面向对象绝不仅仅是逻辑上的归纳，而是电路中的实践结果。
`class`，是对元件结构的描述
`object`，是对元件的具体应用（就像“采购指定型号的元件”一样）
函数也是对象。

话说回来。一个“寄存器”元件，触发后只有一种操作：赋值（D触发器的CLK）。
> 所以，我们本可以认为`return`也就是返回变量本身的值也有门控，但是并没有考虑进去，认为每时每刻都有输出。
> **当然，也可以考虑**。于是分为输入触发和输出触发，`a = b`实际上是`b.set_to(a)`。现在发现考虑选通输出更合理。所以也要考虑“高阻态”时函数的行为，以及在实际电路设计中没有加门控所体现的结果（竞争冒险、默认值、上拉输出下拉输出……）（可以理解为频率无穷大的门控触发）

# 对象的复用
“单线程的语言，导线顺序本可以视为从上到下。”但是已经声明的对象往往重复出现，直接从上往下写出一个copy总是不太合适。所以，应该改成

单线程的语言，导线没有分叉和合并。但是可以多次经过同一个元件。

# 组合逻辑与函数
```verilog
assign c = a + b;
```
和
```c
int c = a + b;
```
的显著不同在于，assign语句不占用步骤。其实assign更像是对于类的声明，使用一次之后就不再重定义，一个信号只能有一个 assign 语句，多次赋值会导致冲突或意外行为。
assign是头文件层面的，C语言的是在源文件层面的。

启示我们，结构设计与流程执行应当分开。

现在，把它们封装成函数。一个是组合逻辑，不需要触发；一个是需要调用的函数，相当于需要触发。现在姑且都视为组合逻辑吧，问题在下面会指出。

# 时序逻辑与函数

前面的函数结构非常简单，可以直接组合逻辑表示，但如果有for循环甚至while判定呢
```python
def randbig():
	a = 0
	while a < 100:
		a = rand()
	return a
```
这样的函数用数字电路表示则必须要有执行流程了
有执行流程，则必将有触发条件
另外，这也意味着函数不再像组合逻辑一样几乎每时每刻都能给出答案（物理层面上其实也做不到，逻辑门有延迟、有竞争冒险）
所以，组合逻辑也可以视为每时每刻触发的时序逻辑，`always @(*)`，“物理世界（如果假设你是虚拟人），也可以视为是无限细分的时间片轮询”

函数被调用时，信号线也传入函数的触发端，函数开始进行运算。
对计算机或者语言解释器来说，函数的结果，未来的事情都不重要；但对于实实在在的电路，要用的元器件已经摆在桌子上了，肯定需要观察还没有执行完毕的中间态会是什么样子。（对于有冒险的组合逻辑也是如此，会观察到结果未稳定之前会有跳变）
输出要有缺省值，可能还需要触发信号/指示信号（触发信号是输入的导线，指示信号是输出的导线）

# 输入触发与输出触发（选通）
再回到这段代码
```c
int a = 3;
bool b = 4;
a = 5;
```
《对象的复用》提到导线穿过同一个元件，也就是有回环。但是之前a赋值3，现在a赋值5，如何体现回环后的不一样？
引入选通输出。在常量池里有1, 2, 3, 4, 5...等常量，但不是谁都能传入a的。第二次，导线穿过5而没穿过3，于是常量5传入a。
```python
a.input(5.output())
```
管道的两端，选通输入触发和选通输出触发都被触发，数据才正确流入。
于是可以认为所有端口之间都有潜在的联通关系，只是大部分关系自始至终都不会被触发。

# 再谈类与对象
C++的类，是结构体的变种，包含变量与函数。
但经过刚才的思考，python的“一切皆对象”的思想在数字电路中也适用，变量和函数都是对象。
两个“对象”的含义或许有些不同。
函数和变量当然可以捆绑在一起组成C++中传统的“对象”，小IC通过胶水粘在一起变成大IC

这个大IC有多个触发端，可以调用其中的多种方法，或者修改其中的多种函数

“对象”从不是结构体的变种，它是编程中对具体事物的抽象范畴。它可以是结构体（表单）描述其他对象，也可以是本身就可以执行的元件。

# 导线的运算
或：线或。
与：具有单稳态触发宽度的与。毕竟在严谨的认知下，信号达到绝对同时传入可以认为是不可能的。

# 对象的产生和销毁
verilog终究不能像python一样，在运行时凭空产生一个对象，它更像C语言，是编译后运行的。
动态语言确实是优雅的，例如LISP……但以后再研究吧
静态语言中，对象的产生和销毁，可以理解为元件的启用和关闭。毕竟，即使在循环结构里产生了大量临时变量，物理上也是有大容量的内存为其提供支持，产生大量对象的程序设计在数字电路设计中本身应该避免。

销毁对象，可以视为所有方法的触发端都失效，元件变成一个悬空的元件。

若多个线程同时调用一个函数，而函数只定义了一个，实际上是有两个临时对象同时工作的

若函数内再递归调用自己，那临时对象又会增加（在计算机中也是，每调用一次自身，就会占用一块内存存储这个函数块），开销较大
网上搜索了一下硬件递归，大家的理解停留在“循环/反馈”上，我认为循环/反馈并不算是递归，递归是在函数内原封不动地调用一个一模一样的函数

# goto、流程控制、循环结构、函数递归
goto语句很直白。把信号线传导回label就是了。
for和while的问题遂迎刃而解了。（为什么当时设计不出乘法器，估计还是因为，一，数码需要排线传递太复杂，二，加法器并没有我模型中必须要有的触发和选通）
函数递归，和循环有本质区别，在于它开辟了新的对象，无非就是启用了一个新元件罢了。
```
{
1
	{
	2
		{
		3
			{
			4
			}
		}
	}
}
和
{
	{
	2
		{
		3
			{
			4
			d
			}
		c
		}
	b
	}
a
}
```
是不一样的，而循环语句只能做到前者（在没有临时变量需要保存的情况下）。
# 异步编程
还是拿python举例吧
```python
async def concurrent_gather():
    results = await asyncio.gather(
        async_task1(param1),
        async_task2(param2),
        async_task3(param2)
    )
    return results
```
在数据流语言中就简单很多了：
	管道分叉，灌入对应的数据；
	导线分叉，同时触发多个元件；
当然，设计时候要开始注意计算延迟，避免竞争冒险了。最简单的方法是用同步的时钟信号，就像sysTick一样统一调度任务。

假如数据流程序clock的频率是10Hz，那对应的顺序的程序的调度器的频率是100Hz，才能最多并行执行十个任务吧。

# 真正的流程图与图形化编程应该怎么画
每个元件的数据管道都要有自己所属的输入触发或输出触发；其他其实按照数字电路画法就可以了
无非是把管道标粗点、导线标细点罢了。

甚至可以在元件里面插入文本框，写顺序程序的代码（comfyUI，或者《图灵完备》游戏……）
